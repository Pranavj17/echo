defmodule TestLead.MessageHandler do
  @moduledoc """
  Handles incoming messages from other agents via Redis pub/sub.

  Subscribes to:
  - messages:test_lead (direct messages)
  - messages:all (broadcasts)
  - messages:leadership (C-suite communications)
  - decisions:* (decision events from engineering team)
  """

  use GenServer
  require Logger

  alias EchoShared.MessageBus

  ## Client API

  def start_link(opts \\ []) do
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end

  ## Server Callbacks

  @impl true
  def init(_opts) do
    Logger.info("TEST_LEAD Message Handler started")

    # Subscribe to TEST_LEAD messages
    {:ok, _} = MessageBus.subscribe_to_role(:test_lead)

    # Subscribe to decision events
    Redix.PubSub.subscribe(:redix_pubsub, ["decisions:new", "decisions:escalated"], self())

    {:ok, %{}}
  end

  @impl true
  def handle_info({:redix_pubsub, _pid, _ref, :message, %{channel: channel, payload: payload}}, state) do
    case Jason.decode(payload) do
      {:ok, message} ->
        handle_message(channel, message)

      {:error, reason} ->
        Logger.error("Failed to decode message: #{inspect(reason)}")
    end

    {:noreply, state}
  end

  @impl true
  def handle_info(_msg, state) do
    {:noreply, state}
  end

  ## Private Functions

  defp handle_message("messages:test_lead", message) do
    Logger.info("TEST_LEAD received message: #{message["subject"]} from #{message["from"]}")

    case message["type"] do
      "request" -> handle_request(message)
      "escalation" -> handle_escalation(message)
      "notification" -> handle_notification(message)
      _ -> Logger.warning("Unknown message type: #{message["type"]}")
    end
  end

  defp handle_message("messages:all", message) do
    Logger.info("TEST_LEAD received broadcast: #{message["subject"]}")
    # Process broadcasts if relevant to TEST_LEAD
  end

  defp handle_message("messages:leadership", message) do
    Logger.info("TEST_LEAD received leadership message: #{message["subject"]}")
    # Handle C-suite communications
  end

  defp handle_message("decisions:new", event) do
    Logger.info("New decision initiated: #{event["decision_id"]} (#{event["type"]})")
    # TEST_LEAD can monitor technical decisions
  end

  defp handle_message("decisions:escalated", event) do
    Logger.warning("Decision escalated: #{event["decision_id"]}")
    # TEST_LEAD should review technical escalations
    handle_escalated_decision(event)
  end

  defp handle_message(_channel, _message) do
    # Ignore other channels
    :ok
  end

  defp handle_request(message) do
    Logger.info("Processing request: #{message["subject"]}")
    # TODO: Process requests based on content
    # For now, just log and acknowledge
  end

  defp handle_escalation(message) do
    Logger.warning("Escalation received: #{message["subject"]}")
    # TODO: Handle escalations requiring TEST_LEAD attention
  end

  defp handle_notification(message) do
    Logger.debug("Notification: #{message["subject"]}")
    # Process informational notifications
  end

  defp handle_escalated_decision(event) do
    # Log escalated decision for TEST_LEAD review
    Logger.warning("""
    ESCALATED DECISION REQUIRES TEST_LEAD REVIEW
    Decision ID: #{event["decision_id"]}
    Reason: #{event["reason"]}
    Urgency: #{event["urgency"]}
    """)
  end
end
